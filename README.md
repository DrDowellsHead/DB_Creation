== Получен Quest 1. Создать файл src/shared.c, в котором реализовать общие операции над таблицами БД (SELECT, INSERT, UPDATE и DELETE) и все необходимые агрегационные запросы (получить все включенные модули, получить все модули на первом уровне памяти и т.д.).
Создать для каждой таблицы БД файл src/[db_name].c с конкретными реализациями функций по обработке отдельной таблицы рассматриваемой БД.
Создать программу src/modules_db.c, в которой разместить точку входа и меню управления (считывание базы, вывод и т.д.).
Добавьте в src/modules_db.c вызов функции, реализующей инструкцию из List 1. Добавить вывод, что в первой ячейке первого уровня находится только главный модуль ИИ, при помощи описанных раннее функций. Для отладки добавить возможность просмотра содержимого всех таблиц, добавления и удаления значений в них.
Добавьте цель build_db в Makefile для сборки приложения. Makefile доджен располагаться в директории src.
Структура БД описана в List 1. Файлы БД находятся в директории /materials.
Подсказка: каждая запись в базе данных представляет из себя тип данных struct с полями в том же порядке, в каком они описаны выше(!).
Пример реализации интерфейса можно найти в материалах.
Использование сторонних библиотек запрещено. ==

*LIST_1*

СУБД стоит спроектировать таким образом, чтобы выделить в виде отдельного общего файла src/shared.c универсальные функции по работе с таблицей БД с реализацией стандартных операций (SELECT, INSERT, UPDATE и DELETE), разместить в отдельные файлы src/[db_name].c конкретные реализации по обработке 3-х таблиц рассматриваемой БД, и вынести в общий файл агрегационные запросы ко всем таблицам. Точку входа и меню управления СУБД разместить в файле в src/modules_db.c.
Когда с СУБД будет закончено, то можно будет покончить и с ИИ. Добавьте в src/modules_db.c вызов функции, реализующую описанную в первом листе инструкцию.
Для этого как раз и понадобятся функции для работы с БД, написанные раньше. В конце обязательно проверьте и выведите, что в первой ячейке первого уровня находится только главный модуль ИИ, снова при помощи написанных раннее функций. Не забудьте добавить для отладки возможность просмотра содержимого всех таблиц, добавления и удаления значений. Какого-то строгого формата входных и выходных значений в этом задании нет (функциональных тестов, соответственно, тоже, однако про clang-format и cppcheck забывать не стоит), но помните - ответственность за интерфейс лежит на ваших плечах. Кто знает, история циклична, и вдруг спасение человечества вновь будет зависеть от этой программы. Не хотелось бы, чтобы эта операция провалилась из-за невозможности разобраться в (пусть и текстовом) интерфейсе вашего эксплойта. Он должен понравиться даже ИИ, хоть и призван его уничтожить.

И да, стоит не забыть сохранить разработанную СУБД в репозитории на будущее!

Хм, написанная реализация попахивает O(n). Это (не) очень (не)эффективно. Есть вероятность, что ИИ раскроет ваш план во время выполнения программы! Возможно, имеет смысл подумать об индексах - упорядоченном по какому-то полю наборе из данных в базе, на котором можно будет реализовать бинарный поиск. Вперед! Это последняя битва естественного интеллекта с искусственным, не оставьте ему никакого шанса!

== Получен Quest 2. Добавить в файл src/shared.c реализацию индекса с бинарным поиском по данным. Индекс реализовать на базе отдельных индексных файлов для каждой таблицы. В минимальном виде - для идентификаторов (id). ==

Сама БД состоит из трех таблиц:

1. Основная таблица модулей ("MODULES") состоит из:
- Id модуля (int);
- Название модуля (char[30]);
- Номер уровня памяти, где находится модуль (int);
- Номер ячейки, где находится модуль на данном уровне (int);
- Флаг удаления (int).
2. Таблица уровней ("LEVELS") состоит из:
- Номера уровня памяти (int);
- Кол-ва ячеек на уровне (int);
- Флаг защищенности (int).
3. Таблица событий изменения статуса ("STATUS_EVENTS") состоит из:
- Id события (int);
- Id модуля (int);
- Новый статус модуля (int);
- Дата изменения статуса (char[10 + 1] вида "dd.mm.yyyy\0");
- Время изменения статуса (char[8 + 1] вида "hh:mm:ss\0").


